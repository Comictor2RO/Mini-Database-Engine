================================================================
DOCUMENTATIE TEHNICA — Mini Database Engine
================================================================

----------------------------------------------------------------
AST/ — Abstract Syntax Tree
----------------------------------------------------------------
Contine reprezentarea in memorie a query-urilor SQL parsate.

Statement
    Clasa de baza abstracta pentru toate statement-urile.
    Defineste interfata execute().

SelectStatement
    Reprezinta un query SELECT.
    Contine coloanele selectate, tabela si conditia optionala WHERE.

InsertStatement
    Reprezinta un query INSERT.
    Contine tabela, coloanele optionale si valorile de inserat.

DeleteStatement
    Reprezinta un query DELETE.
    Contine tabela si conditia optionala WHERE.

CreateStatement
    Reprezinta un query CREATE TABLE.
    Contine tabela si lista de coloane cu tipurile lor.

Condition
    Struct care reprezinta o conditie WHERE.
    Campuri: column, op, value.
    Exemplu: age > 18 -> { column="age", op=">", value="18" }

Columns
    Struct care reprezinta o coloana dintr-o tabela.
    Campuri: name, type.
    Exemplu: { name="age", type="INT" }

Row
    Struct care reprezinta un rand de date ca vector de string-uri.
    Exemplu: { values=["Ana", "25", "ana@email.com"] }

----------------------------------------------------------------
Frontend/ — Interfata cu utilizatorul
----------------------------------------------------------------
Transforma string-ul SQL intr-un obiect AST.

TokenType
    Enum cu tipurile de token-uri:
    KEYWORD, IDENTIFIER, NUMBER, STRING,
    OPERATOR, PUNCTUATION, WILDCARD, END_OF_FILE

Token
    Struct cu tipul si valoarea unui token.
    Exemplu: { type=KEYWORD, value="SELECT" }

Lexer
    Primeste un string SQL si il sparge in vector<Token>.
    Trateaza:
    - keywords    : SELECT, INSERT, DELETE, CREATE, FROM, WHERE, INTO, VALUES
    - identifiers : numele tabelelor si coloanelor
    - numbers     : 18, 42, 100
    - strings     : 'Ana', 'email@test.com'
    - operators   : =, !=, >, <, >=, <=
    - punctuation : ( ) ,
    - wildcard    : *

Parser
    Primeste vector<Token> si construieste obiectul AST corespunzator.
    Metoda principala: parse() -> Statement*
    Metode interne:
    - parseSelect()    -> SelectStatement*
    - parseInsert()    -> InsertStatement*
    - parseDelete()    -> DeleteStatement*
    - parseCreate()    -> CreateStatement*
    - parseCondition() -> Condition*
    Validare: returneaza nullptr daca primul token nu e KEYWORD.

----------------------------------------------------------------
Storage/ — Stocarea datelor pe disc
----------------------------------------------------------------
Gestioneaza citirea si scrierea datelor in fisiere binare.

PageHeader
    Struct de 12 bytes stocat la inceputul fiecarei pagini.
    Campuri:
    - pageId    (int) : numarul paginii
    - freeSpace (int) : spatiul liber ramas in bytes
    - rowNumber (int) : numarul de randuri stocate
    Verificat la compilare: static_assert(sizeof(PageHeader) == 12)

Page
    Reprezinta o pagina de 4096 bytes in memorie.
    Structura interna:
    [ PageHeader (12 bytes) | date randuri... | spatiu liber ]
    Randurile sunt separate prin '\n'.
    Metode:
    - addRow(row)    : scrie randul in data[] si actualizeaza headerul
    - getRows()      : citeste data[] si returneaza randurile ca vector<string>
    - hasSpace(size) : verifica daca mai e loc pentru un rand
    - getBuffer()    : returneaza const char* catre data[] pentru I/O disc

PageManager
    Gestioneaza fisierul .db.
    La constructie:
    - daca fisierul nu exista -> il creeaza
    - daca exista -> calculeaza numberOfPages = fileSize / PAGE_SIZE
    Operatii:
    - insertRow(row)   : gaseste pagina cu spatiu liber sau creeaza una noua
    - getAllRows()     : citeste toate paginile si returneaza toate randurile
    - writePage(id, p) : scrie pagina la pozitia id * PAGE_SIZE in fisier
    - readPage(id)     : citeste pagina de la pozitia id * PAGE_SIZE
    - clearAll()       : sterge continutul fisierului (folosit in deleteRow)
    Toate operatiile folosesc modul binar (std::ios::binary).

----------------------------------------------------------------
Catalog/ — Schema bazei de date
----------------------------------------------------------------
Tine evidenta tabelelor si coloanelor lor in memorie.

Catalog
    Stocheaza un map<string, vector<Columns>>.
    Asociaza numele fiecarei tabele cu lista ei de coloane.
    Metode:
    - createTable(name, columns) : creeaza tabela daca nu exista deja
    - tableExists(name)          : verifica daca tabela exista
    - getColumns(name)           : returneaza coloanele tabelei

----------------------------------------------------------------
Table/ — Operatii pe o tabela
----------------------------------------------------------------
Leaga schema (Catalog) de storage (PageManager).

Table
    Combina PageManager si schema tabelei.
    Serializare: Row{"Ana","25"} -> "Ana|25" (stocat in pagina)
    Deserializare: "Ana|25" -> Row{"Ana","25"} (la citire)
    Metode:
    - insertRow(row)  : serialzeaza randul si il trimite la PageManager
    - selectRow(cond) : citeste toate randurile, filtreaza dupa conditie
                        daca cond == nullptr -> returneaza toate randurile
    - deleteRow(cond) : citeste tot, pastreaza randurile care NU se
                        potrivesc, sterge fisierul, rescrie randurile ramase
    Evaluare conditie (evaluateCondition):
    - gaseste indexul coloanei in schema
    - compara valoarea randului cu valoarea conditiei
    - suporta: =, !=, >, <, >=, <=

----------------------------------------------------------------
Engine/ — Execution Engine
----------------------------------------------------------------
Leaga Parser-ul de Table si Catalog. Componenta centrala a engine-ului.

Engine
    Primeste un Catalog prin referinta la constructie.
    Metoda principala: execute(Statement*)
    - foloseste dynamic_cast pentru a determina tipul statement-ului
    - apeleaza metoda corespunzatoare
    Metode interne:
    - executeCreate(stmt) : apeleaza catalog.createTable()
    - executeInsert(stmt) : ia schema din catalog, creeaza Table,
                            construieste Row din values si apeleaza insertRow()
    - executeSelect(stmt) : ia schema din catalog, creeaza Table,
                            apeleaza selectRow() si afiseaza rezultatele
    - executeDelete(stmt) : ia schema din catalog, creeaza Table,
                            apeleaza deleteRow()

----------------------------------------------------------------
StringUtils/ — Utilitati
----------------------------------------------------------------

split(str, delimiter)
    Sparge un string dupa un delimiter si returneaza vector<string>.
    Folosita in Table pentru a deserializa randurile stocate.
    Exemplu: split("Ana|25|email", '|') -> {"Ana", "25", "email"}

----------------------------------------------------------------
FLUXUL COMPLET AL UNUI QUERY
----------------------------------------------------------------

Exemplu: "INSERT INTO users VALUES (1, Ion, 25)"

  STRING SQL
      |
      v
  [ LEXER ]
  Tokenizeaza string-ul
      |
      v
  [INSERT][INTO][users][VALUES][(][1][,][Ion][,][25][)]
      |
      v
  [ PARSER ]
  Construieste obiectul AST
      |
      v
  InsertStatement { table="users", values=["1","Ion","25"] }
      |
      v
  [ ENGINE ]
  executeInsert():
  - catalog.getColumns("users") -> schema
  - Table table("users", schema)
  - row.values = ["1", "Ion", "25"]
  - table.insertRow(row)
      |
      v
  [ TABLE ]
  Serialzeaza: "1|Ion|25"
  pageManager.insertRow("1|Ion|25")
      |
      v
  [ PAGE MANAGER ]
  Gaseste pagina cu spatiu liber
  page.addRow("1|Ion|25")
  writePage() -> users.db (fisier binar)

----------------------------------------------------------------
EXEMPLU DE UTILIZARE (main.cpp)
----------------------------------------------------------------

  Catalog catalog;
  Engine engine(catalog);

  Queries rulate in ordine:
  1. CREATE TABLE users (id INT, name STRING, age INT)
     -> catalog retine schema tabelei

  2. INSERT INTO users VALUES (1, Ion, 25)
  3. INSERT INTO users VALUES (2, Ana, 30)
  4. INSERT INTO users VALUES (3, Popa, 40)
     -> randurile sunt scrise in users.db

  5. SELECT * FROM users
     -> afiseaza toate randurile

  6. SELECT * FROM users WHERE id = 2
     -> afiseaza doar randul cu id=2

  7. DELETE FROM users WHERE id = 2
     -> sterge randul cu id=2

  8. SELECT * FROM users
     -> afiseaza randurile ramase (1 si 3)

----------------------------------------------------------------
STATUS IMPLEMENTARE
----------------------------------------------------------------

[DONE]
  - AST complet (Statement, Select, Insert, Delete, Create,
                 Condition, Columns, Row)
  - Lexer (tokenizare completa)
  - Parser (SELECT, INSERT, DELETE, CREATE, Condition)
  - Storage (PageHeader, Page, PageManager)
  - Catalog
  - Table (insert, select, delete cu evaluare conditii)
  - Engine (execution engine end-to-end)
  - StringUtils

[TODO]
  - B+ Tree Index
  - Page Cache (LRU)
  - Write-Ahead Logging (WAL)

[EXTENSII HARD MODE]
  - Query planner + cost estimation
  - Concurenta (MVCC simplificat)

================================================================
